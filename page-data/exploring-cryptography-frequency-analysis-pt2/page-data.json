{"componentChunkName":"component---src-templates-blog-post-js","path":"/exploring-cryptography-frequency-analysis-pt2/","result":{"data":{"site":{"siteMetadata":{"title":"Living Life on the Outside","author":"Lucian Buzzo"}},"markdownRemark":{"id":"876accc5-959a-553a-ab84-5caf5f822b6c","excerpt":"In my previous post, I explored frequency analysis and how it can be used to break simple substitution ciphers, specifically the Caesar…","html":"<p>In <a href=\"https://lucianbuzzo.com/exploring-cryptography-frequency-analysis/\">my previous post</a>, I explored frequency analysis and how it can be used to break simple substitution ciphers, specifically the Caesar cipher. I also highlighted how the Caesar cipher can be cracked using brute force and a word list. Using a word list didn’t feel particularly satisfying to me though, so in this post I’ll look at breaking the Caesar cipher using frequency analysis alone.</p>\n<p>To begin with, I need a baseline letter frequency table to compare against. As before, I’m going to use the <a href=\"https://pi.math.cornell.edu/~mec/2003-2004/cryptography/subs/frequencies.html\">frequency table from Cornell’s website</a>, adjusted to provide values between 0 and 1.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">STANDARD_FREQUENCIES</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">a</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0812</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">b</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0149</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">c</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0271</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">d</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0432</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">e</span><span class=\"token operator\">:</span> <span class=\"token number\">0.1202</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">f</span><span class=\"token operator\">:</span> <span class=\"token number\">0.023</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">g</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0203</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">h</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0592</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">i</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0731</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">j</span><span class=\"token operator\">:</span> <span class=\"token number\">0.001</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">k</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0069</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">l</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0398</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">m</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0261</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">n</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0695</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">o</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0768</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">p</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0182</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">q</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0011</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">r</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0602</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">s</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0628</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">t</span><span class=\"token operator\">:</span> <span class=\"token number\">0.091</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">u</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0288</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">v</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0111</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">w</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0209</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">x</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0017</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">y</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0211</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">z</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0007</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This gives us a baseline to compare against, but we need to normalize the frequencies of the ciphertext to match the standard frequencies. To do this, we need to count the number of occurrences of each letter in the ciphertext, and then divide each count by the total number of letters in the ciphertext (this is the same function used previously, copied here for clarity).</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">frequencyAnalysis</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> processedText <span class=\"token operator\">=</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^a-zA-Z]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> charFrequency <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> char <span class=\"token keyword\">of</span> processedText<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>charFrequency<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      charFrequency<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      charFrequency<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">const</span> totalChars <span class=\"token operator\">=</span> processedText<span class=\"token punctuation\">.</span>length\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> char <span class=\"token keyword\">in</span> charFrequency<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    charFrequency<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> charFrequency<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">/</span> totalChars\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> charFrequency\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We can now take a ciphertext, and generate a set of letter frequencies for it. We can then compare these frequencies to the standard frequencies and see if the results are similar. An intuitive way to understand this is to visualize the sets of frequencies as a bar chart. If the high points and low points on the bar chart correspond to the same letters, then the two sets of frequencies are similar and it’s likely that we have the correct <a href=\"https://en.wikipedia.org/wiki/Key_(cryptography)\">key</a>. Just for fun, lets make a simple aasci bar chart generator:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">aasciBarChart</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">data</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> max <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> entries <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b <span class=\"token operator\">?</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n  entries<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> length <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">/</span> max<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">50</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> bar <span class=\"token operator\">=</span> <span class=\"token string\">'▒'</span><span class=\"token punctuation\">.</span><span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span>length<span class=\"token punctuation\">)</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>bar<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If we plug in the standard frequencies, we get the following chart:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nb: ▒▒▒▒▒▒\nc: ▒▒▒▒▒▒▒▒▒▒▒\nd: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\ne: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nf: ▒▒▒▒▒▒▒▒▒▒\ng: ▒▒▒▒▒▒▒▒\nh: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\ni: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nj:\nk: ▒▒▒\nl: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nm: ▒▒▒▒▒▒▒▒▒▒▒\nn: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\no: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\np: ▒▒▒▒▒▒▒▒\nq:\nr: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\ns: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nt: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nu: ▒▒▒▒▒▒▒▒▒▒▒▒\nv: ▒▒▒▒▒\nw: ▒▒▒▒▒▒▒▒▒\nx: ▒\ny: ▒▒▒▒▒▒▒▒▒\nz:</code></pre></div>\n<p>In the chart you can see a big spike on the letters <code class=\"language-text\">e</code>, <code class=\"language-text\">t</code>, <code class=\"language-text\">a</code> and <code class=\"language-text\">o</code>, as they are the most commonly occurring letters. Conversely we can also see dips on the least common letters: <code class=\"language-text\">x</code>, <code class=\"language-text\">q</code>, <code class=\"language-text\">j</code> and <code class=\"language-text\">z</code>.</p>\n<p>Now lets plug in a ciphertext encoded with a Caesar cipher using a key of 3:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a: ▒\nb: ▒▒▒▒▒▒\nc:\nd: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\ne: ▒▒▒▒▒▒▒▒▒▒\nf: ▒▒▒▒▒▒▒▒▒▒▒▒\ng: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nh: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\ni: ▒▒▒▒▒▒▒▒▒▒\nj: ▒▒▒▒▒▒▒▒\nk: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nl: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nm: ▒\nn: ▒▒▒▒▒▒▒\no: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\np: ▒▒▒▒▒▒▒▒\nq: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nr: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\ns: ▒▒▒▒▒▒\nt:\nu: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nv: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nw: ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\nx: ▒▒▒▒▒▒▒▒▒▒▒\ny: ▒▒▒\nz: ▒▒▒▒▒▒▒▒</code></pre></div>\n<p>As you can see our peaks have shifted (as expected), instead of seeing a peak on <code class=\"language-text\">e</code> we now see a peak on <code class=\"language-text\">h</code>. This is because the Caesar cipher shifts the alphabet by 3, so <code class=\"language-text\">e</code> becomes <code class=\"language-text\">h</code>, <code class=\"language-text\">t</code> becomes <code class=\"language-text\">w</code>, <code class=\"language-text\">a</code> becomes <code class=\"language-text\">d</code> and <code class=\"language-text\">o</code> becomes <code class=\"language-text\">r</code>.</p>\n<p>We can now right an algorithm that iterates through all of the 26 possible keys for a Caesar cipher and finds the best match based on how close the letter frequency of deciphered text matches the letter frequency of the English language. For each letter in the frequency set generated for the deciphered text, we calculate the difference between the letter frequency of the deciphered text and the letter frequency of the English language. We then sum all of these differences to get a total difference for the deciphered text. The key that produces the lowest total difference is the most likely key for the Caesar cipher. We can utilize <code class=\"language-text\">Math.abs</code> here to make sure we always get a positive number when checking the difference.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">crackWithFrequencyAnalysis</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cipherText</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> bestShift <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">let</span> bestScore <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> shift <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> shift <span class=\"token operator\">&lt;</span> alphabet<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> shift<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> decipheredText <span class=\"token operator\">=</span> <span class=\"token function\">caesarDecipher</span><span class=\"token punctuation\">(</span>shift<span class=\"token punctuation\">,</span> cipherText<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> letterFrequency <span class=\"token operator\">=</span> <span class=\"token function\">frequencyAnalysis</span><span class=\"token punctuation\">(</span>decipheredText<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> score <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>letterFrequency<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">acc<span class=\"token punctuation\">,</span> letter</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> frequency <span class=\"token operator\">=</span> letterFrequency<span class=\"token punctuation\">[</span>letter<span class=\"token punctuation\">]</span>\n      <span class=\"token keyword\">const</span> standardFrequency <span class=\"token operator\">=</span> <span class=\"token constant\">STANDARD_FREQUENCIES</span><span class=\"token punctuation\">[</span>letter<span class=\"token punctuation\">]</span>\n      <span class=\"token keyword\">return</span> acc <span class=\"token operator\">+</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>frequency <span class=\"token operator\">-</span> standardFrequency<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>score <span class=\"token operator\">&lt;</span> bestScore<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      bestScore <span class=\"token operator\">=</span> score\n      bestShift <span class=\"token operator\">=</span> shift\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">caesarDecipher</span><span class=\"token punctuation\">(</span>bestShift<span class=\"token punctuation\">,</span> cipherText<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Let’s see how this works using our example ciphertext and Caesar algorithm from the previous article:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> cipherText <span class=\"token operator\">=</span> <span class=\"token function\">caesarCipher</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n    The primary thing when you take a sword in your hands is your intention to cut the enemy, \n    whatever the means. Whenever you parry, hit, spring, strike or touch the enemy's cutting \n    sword, you must cut the enemy in the same movement. It is essential to attain this. \n    If you think only of hitting, springing, striking or touching the enemy, you will not be \n    able actually to cut him.\n</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">crackWithFrequencyAnalysis</span><span class=\"token punctuation\">(</span>cipherText<span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// -> theprimarythingwhenyoutakeaswordinyourhandsisyourintentiontocuttheenemywhateverthemeanswheneveryouparryhitspringstrikeortouchtheenemyscuttingswordyoumustcuttheenemyinthesamemovementitisessentialtoattainthisifyouthinkonlyofhittingspringingstrikingortouchingtheenemyyouwillnotbeableactuallytocuthim</span></code></pre></div>\n<p>Nice! We’ve successfully cracked the Caesar cipher using frequency analysis, without having to rely on word lists. This method works best with big blocks of text, so it’s not ideal for cracking short messages. I’d like to create an experiment to see, on average, what length of text is required for the cracking algorithm to have 100% success rate. To do this, I’ll use random blocks of text generated from <a href=\"https://randomtextgenerator.com/\">https://randomtextgenerator.com/</a>, iteratively increasing the length of the text being used. I can then run the cracking algorithm and see if it successfully cracks the cipher (I’ll refactor the cracking algorithm to return the key instead of the deciphered text). If I get 100% of the samples cracked for a given length of text, I exit the loop and return the length of text that was used.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">KEY</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">SAMPLE_SIZE</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">ITERATIONS</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n\n<span class=\"token keyword\">const</span> lengthForAccuracy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>lengthForAccuracy<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> <span class=\"token constant\">ITERATIONS</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> matches <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">let</span> samples <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token comment\">// Run SAMPLE_SIZE random samples of `i` length</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>samples <span class=\"token operator\">&lt;</span> <span class=\"token constant\">SAMPLE_SIZE</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Random number between 0 and the length of the text minus i</span>\n      <span class=\"token keyword\">const</span> j <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      samples<span class=\"token operator\">++</span>\n      <span class=\"token comment\">// Get a random sample of `i` length</span>\n      <span class=\"token keyword\">const</span> sample <span class=\"token operator\">=</span> <span class=\"token function\">caesarCipher</span><span class=\"token punctuation\">(</span><span class=\"token constant\">KEY</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">,</span> j <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\">// Check to see if the crack was correct</span>\n      <span class=\"token keyword\">const</span> crack <span class=\"token operator\">=</span> <span class=\"token function\">crackWithFrequencyAnalysis</span><span class=\"token punctuation\">(</span>sample<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>crack <span class=\"token operator\">===</span> <span class=\"token constant\">KEY</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        matches<span class=\"token operator\">++</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// If we have 100% success, exit the loop</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>matches <span class=\"token operator\">===</span> samples<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      lengthForAccuracy<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">break</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> average <span class=\"token operator\">=</span>\n  lengthForAccuracy<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">acc<span class=\"token punctuation\">,</span> val</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> acc <span class=\"token operator\">+</span> val<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span>\n  lengthForAccuracy<span class=\"token punctuation\">.</span>length\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>average<span class=\"token punctuation\">)</span></code></pre></div>\n<p>This takes a while to run, but I get an average length of text required for 100% success of 82.6 characters with my test data, which I’ve <a href=\"https://gist.github.com/LucianBuzzo/626a08a14ed48169e6263522d8722bbf\">posted in a gist here</a>. This is a somewhat naive approach, and it depends heavily on the text being analysed, but it’s a good starting point and I think it shows that frequency analysis can work on even short messages (82 characters is not a lot!). As a follow up to this exercise I’d like to see how this approach can be generalized to other substitution ciphers, where the key, and even method is unknown.</p>\n<p>I hope you’ve enjoyed this article, and learned something along the way. If you have any questions or comments, please let me know in the comments below, or hit me up on Twitter <a href=\"https://twitter.com/LucianBuzzo\">@LucianBuzzo</a>.</p>\n<h2>Further reading</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Cipher\">Wikipedia: Cipher</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Substitution_cipher\">Wikipedia: Substitution cipher</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Caesar_cipher\">Wikipedia: Caesar cipher</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Frequency_analysis\">Wikipedia: Frequency analysis</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Cryptanalysis\">Wikipedia: Cryptanalysis</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Brute-force_attack\">Wikipedia: Brute force attack</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Dictionary_attack\">Wikipedia: Dictionary attack</a></li>\n<li><a href=\"https://books.google.co.uk/books/about/In_Code.html\">In Code: A Mathematical Journey</a></li>\n<li><a href=\"https://simonsingh.net/books/the-code-book/\">The Code Book</a></li>\n</ul>","frontmatter":{"title":"Exploring Cryptography - Frequency Analysis pt.2","date":"March 20, 2023"}}},"pageContext":{"slug":"/exploring-cryptography-frequency-analysis-pt2/","previous":{"fields":{"slug":"/exploring-cryptography-frequency-analysis/"},"frontmatter":{"title":"Exploring Cryptography - Frequency Analysis"}},"next":null}},"staticQueryHashes":[],"slicesMap":{}}