{"componentChunkName":"component---src-templates-blog-post-js","path":"/exploring-cryptography-frequency-analysis-pt-2/","result":{"data":{"site":{"siteMetadata":{"title":"Living Life on the Outside","author":"Lucian Buzzo"}},"markdownRemark":{"id":"6a301d5b-ea22-5ade-807e-9bd49b6cd2e6","excerpt":"In this article we will be looking at a simple technique for breaking a simple substitution cipher. This technique is called frequency…","html":"<p>In this article we will be looking at a simple technique for breaking a simple substitution cipher. This technique is called frequency analysis, and is one of the simplest techniques for breaking a simple substitution cipher. It is also one of the most effective, and is often used as a first step in breaking a cipher.</p>\n<p>A simple substitution cipher is one where each letter in the plaintext is replaced with a different letter in the ciphertext. A classic example of a simple substitution cipher is the Caesar cipher, where each letter in the plaintext is replaced with the letter 3 places to the right in the alphabet. For example, the letter <code class=\"language-text\">a</code> would be replaced with the letter <code class=\"language-text\">d</code>, the letter <code class=\"language-text\">b</code> would be replaced with the letter <code class=\"language-text\">e</code>, and so on.</p>\n<p>Unfortunately, this approach to encryption, where we substitute each letter in the plaintext with a different letter in the ciphertext, is not very secure. This is because it is very easy to break. All we need to do is look at the frequency of letters in the ciphertext, and then compare that to the frequency of letters in the English language. We can then use this information to work out which letters in the ciphertext correspond to which letters in the plaintext. This applies to any simple substitution cipher, not just the Caesar cipher, so even if we don’t know which cipher was used, we can still break it. This applies to ciphers that use a different shift distance or a different alphabet (even made up symbols), as long as we know the language that the plaintext was written in.</p>\n<h2>Frequency Analysis</h2>\n<p>It’s important to note t the most common letter is typically considered to be <code class=\"language-text\">e</code>, followed by <code class=\"language-text\">t</code>, <code class=\"language-text\">a</code>, <code class=\"language-text\">o</code>, <code class=\"language-text\">i</code>, <code class=\"language-text\">n</code>, <code class=\"language-text\">s</code>, <code class=\"language-text\">h</code>, <code class=\"language-text\">r</code>, and <code class=\"language-text\">d</code>. The least common letter is typically considered to be <code class=\"language-text\">q</code>, followed by <code class=\"language-text\">z</code>, <code class=\"language-text\">x</code>, <code class=\"language-text\">j</code>, <code class=\"language-text\">k</code>, <code class=\"language-text\">v</code>, <code class=\"language-text\">b</code>, <code class=\"language-text\">p</code>, <code class=\"language-text\">y</code>, and <code class=\"language-text\">w</code>. It’s important to note that letter frequency will vary depending on the text sampled, but this is a good approximation for the English language.\nFor this article, I’m going to be using the <a href=\"https://pi.math.cornell.edu/~mec/2003-2004/cryptography/subs/frequencies.html\">frequency data from Cornell’s cryptography course</a>, which is based on a sample of 40,000 words from the English language.\nBy comparing the frequency of letters in the ciphertext to the frequency of letters in the English language, we can work out which letters in the ciphertext correspond to which letters in the plaintext. For example, if we look at the frequency of letters in the ciphertext, and we see that the letter <code class=\"language-text\">b</code> is the most common, we can begin to crack the cipher by assuming that the letter <code class=\"language-text\">b</code> in the ciphertext corresponds to the letter <code class=\"language-text\">e</code> in the plaintext (<code class=\"language-text\">e</code> being the most common letter in plain English). We can then repeat this process for the rest of the letters in the ciphertext, and we should be able to work out which letters in the ciphertext correspond to which letters in the plaintext.</p>\n<p>If we know that a Caesar cipher was used, we can use the frequency analysis technique to work out the shift distance. For example, if we know that the letter <code class=\"language-text\">b</code> in the ciphertext corresponds to the letter <code class=\"language-text\">e</code> in the plaintext, we can work out that the shift distance is 3. This is because the letter <code class=\"language-text\">b</code> is 3 letters to the right of the letter <code class=\"language-text\">e</code> in the alphabet. We can then use this information to decrypt the ciphertext.</p>\n<h2>Breaking the Caesar Cipher</h2>\n<p>Let’s start with a simple Caesar cipher implementation in JavaScript:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> alphabet <span class=\"token operator\">=</span> <span class=\"token string\">'abcdefghijklmnopqrstuvwxyz'</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">caesarCipher</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">text<span class=\"token punctuation\">,</span> shift <span class=\"token operator\">=</span> <span class=\"token number\">3</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">const</span> input <span class=\"token operator\">=</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> input<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> letter <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>alphabet<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>letter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> index <span class=\"token operator\">=</span> alphabet<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>letter<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">const</span> newIndex <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">+</span> shift<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> alphabet<span class=\"token punctuation\">.</span>length\n      result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>newIndex<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">index</span> <span class=\"token operator\">=></span> alphabet<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Using this function, we can encrypt a text using the Caesar cipher:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> cipherText <span class=\"token operator\">=</span> <span class=\"token function\">caesarCipher</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n    The primary thing when you take a sword in your hands is your intention to cut the enemy, \n    whatever the means. Whenever you parry, hit, spring, strike or touch the enemy's cutting \n    sword, you must cut the enemy in the same movement. It is essential to attain this. \n    If you think only of hitting, springing, striking or touching the enemy, you will not be \n    able actually to cut him.\n</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>To produce the following ciphertext:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">wkhsulpdubwklqjzkhqbrxwdnhdvzruglqbrxukdqgvlvbrxulqwhqwlrqwrfxwwkhhqhpbzkdwhyhuwkhphdqvzkhqhyhubrxsduubklwvsulqjvwulnhruwrxfkwkhhqhpbvfxwwlqjvzrugbrxpxvwfxwwkhhqhpblqwkhvdphpryhphqwlwlvhvvhqwldowrdwwdlqwklvlibrxwklqnrqobriklwwlqjvsulqjlqjvwulnlqjruwrxfklqjwkhhqhpbbrxzlooqrwehdeohdfwxdoobwrfxwklp</code></pre></div>\n<p>The next thing we want to do is write a function that can perform frequency analysis on a given ciphertext:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">frequencyAnalysis</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Process the text: remove special characters, convert to lowercase</span>\n  <span class=\"token keyword\">const</span> processedText <span class=\"token operator\">=</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^a-zA-Z]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// Initialize an empty object to store the character frequencies</span>\n  <span class=\"token keyword\">const</span> charFrequency <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// Iterate through each character in the processed text</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> char <span class=\"token keyword\">of</span> processedText<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// If the character is already in the object, increment its count</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>charFrequency<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      charFrequency<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// If the character is not in the object, add it with a count of 1</span>\n      charFrequency<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// Calculate the total number of characters</span>\n  <span class=\"token keyword\">const</span> totalChars <span class=\"token operator\">=</span> processedText<span class=\"token punctuation\">.</span>length\n\n  <span class=\"token comment\">// Iterate through each character in the object and calculate the frequency</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> char <span class=\"token keyword\">in</span> charFrequency<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    charFrequency<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> charFrequency<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">/</span> totalChars\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> charFrequency\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This function returns a map of each character in the ciphertext to its frequency. For example, if we pass the ciphertext from the previous section into this function, we get the following output:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">w</span><span class=\"token operator\">:</span> <span class=\"token number\">0.125</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">k</span><span class=\"token operator\">:</span> <span class=\"token number\">0.06418918918918919</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">h</span><span class=\"token operator\">:</span> <span class=\"token number\">0.10810810810810811</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">s</span><span class=\"token operator\">:</span> <span class=\"token number\">0.013513513513513514</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">u</span><span class=\"token operator\">:</span> <span class=\"token number\">0.05405405405405406</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">l</span><span class=\"token operator\">:</span> <span class=\"token number\">0.09121621621621621</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">p</span><span class=\"token operator\">:</span> <span class=\"token number\">0.037162162162162164</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">d</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0472972972972973</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">b</span><span class=\"token operator\">:</span> <span class=\"token number\">0.05067567567567568</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">q</span><span class=\"token operator\">:</span> <span class=\"token number\">0.09121621621621621</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">j</span><span class=\"token operator\">:</span> <span class=\"token number\">0.02702702702702703</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">z</span><span class=\"token operator\">:</span> <span class=\"token number\">0.02027027027027027</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">r</span><span class=\"token operator\">:</span> <span class=\"token number\">0.07094594594594594</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">x</span><span class=\"token operator\">:</span> <span class=\"token number\">0.05067567567567568</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">n</span><span class=\"token operator\">:</span> <span class=\"token number\">0.013513513513513514</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">v</span><span class=\"token operator\">:</span> <span class=\"token number\">0.05405405405405406</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">g</span><span class=\"token operator\">:</span> <span class=\"token number\">0.010135135135135136</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">f</span><span class=\"token operator\">:</span> <span class=\"token number\">0.02364864864864865</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">y</span><span class=\"token operator\">:</span> <span class=\"token number\">0.010135135135135136</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">o</span><span class=\"token operator\">:</span> <span class=\"token number\">0.02364864864864865</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">i</span><span class=\"token operator\">:</span> <span class=\"token number\">0.006756756756756757</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">e</span><span class=\"token operator\">:</span> <span class=\"token number\">0.006756756756756757</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>From this analysis, we can see that the most common letter in the ciphertext is <code class=\"language-text\">w</code>, followed by <code class=\"language-text\">h</code>, <code class=\"language-text\">q</code> and <code class=\"language-text\">l</code>. Assuming that we don’t have prior knowledge of the shift distance used in the Caesar cipher, we can start by assuming that one of these 4 letters corresponds to the letter <code class=\"language-text\">e</code> in the plaintext. We can then use this information to work out the shift distance. For example, if we assume that the letter <code class=\"language-text\">w</code> in the ciphertext corresponds to the letter <code class=\"language-text\">e</code> in the plaintext, we can work out that the shift distance is 18. This is because the letter <code class=\"language-text\">w</code> is 18 letters to the right of the letter <code class=\"language-text\">e</code> in the alphabet. We can then use this information to decrypt the ciphertext.</p>\n<p>Let’s write a function that will decipher a Caesar cipher for us:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">caesarDecipher</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">shift<span class=\"token punctuation\">,</span> text</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Invert the original shift distance to get the plaintext</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">caesarCipher</span><span class=\"token punctuation\">(</span>alphabet<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> shift<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We can now use this function to try and decipher the ciphertext from the previous section by calculating the shift distance for each of the 4 most common letters in the ciphertext. If any of these shift distances produce readable text, we can assume that we have found the correct shift distance.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Utility function for finding shift distance for `e` from a given letter</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">findShiftDistance</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">letter</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> index <span class=\"token operator\">=</span> alphabet<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>letter<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">-</span> alphabet<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'e'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> alphabet<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> alphabet<span class=\"token punctuation\">.</span>length\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Find the shift distance for each of the 4 most common letters</span>\n<span class=\"token keyword\">const</span> shiftDistances <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token function\">frequencyAnalysis</span><span class=\"token punctuation\">(</span>cipherText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n      <span class=\"token function\">frequencyAnalysis</span><span class=\"token punctuation\">(</span>cipherText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token function\">frequencyAnalysis</span><span class=\"token punctuation\">(</span>cipherText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>findShiftDistance<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Try each shift distance and print the result</span>\nshiftDistances<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">shift</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'checking shift distance'</span><span class=\"token punctuation\">,</span> shift<span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">caesarDecipher</span><span class=\"token punctuation\">(</span>shift<span class=\"token punctuation\">,</span> cipherText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>This will print the following output:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">checking shift distance 18\nespactxlcjestyrhspyjzfelvpldhzcotyjzfcslyodtdjzfctyepyetzyeznfeesppypxjhslepgpcespxplydhspypgpcjzfalccjstedactyrdectvpzcezfnsesppypxjdnfeetyrdhzcojzfxfdenfeesppypxjtyespdlxpxzgpxpyetetdpddpyetlwezleeltyestdtqjzfestyvzywjzqsteetyrdactyrtyrdectvtyrzcezfnstyresppypxjjzfhtwwyzemplmwplneflwwjeznfestx\nchecking shift distance 3\ntheprimarythingwhenyoutakeaswordinyourhandsisyourintentiontocuttheenemywhateverthemeanswheneveryouparryhitspringstrikeortouchtheenemyscuttingswordyoumustcuttheenemyinthesamemovementitisessentialtoattainthisifyouthinkonlyofhittingspringingstrikingortouchingtheenemyyouwillnotbeableactuallytocuthim\nchecking shift distance 7\npdalneiwnupdejcsdajukqpwgawosknzejukqndwjzoeoukqnejpajpekjpkyqppdaajaiusdwparanpdaiawjosdajaranukqlwnnudepolnejcopnegaknpkqydpdaajaiuoyqppejcosknzukqiqopyqppdaajaiuejpdaowiaikraiajpepeoaooajpewhpkwppwejpdeoebukqpdejgkjhukbdeppejcolnejcejcopnegejcknpkqydejcpdaajaiuukqsehhjkpxawxhawypqwhhupkyqpdei\nchecking shift distance 12\nkyvgizdripkyzexnyvepflkrbvrjnfiuzepfliyreujzjpflizekvekzfekftlkkyvvevdpnyrkvmvikyvdvrejnyvevmvipflgriipyzkjgizexjkizbvfikfltykyvvevdpjtlkkzexjnfiupfldljktlkkyvvevdpzekyvjrdvdfmvdvekzkzjvjjvekzrckfrkkrzekyzjzwpflkyzebfecpfwyzkkzexjgizexzexjkizbzexfikfltyzexkyvvevdppflnzccefksvrscvrtklrccpkftlkyzd</code></pre></div>\n<p>We can see that when the shift distance of 3 is used, the plaintext is readable. This means that the shift distance is 3, result!</p>\n<h2>Removing the Human Element</h2>\n<p>But surely we can do better than this? Currently we need to use some human intuition to detect the shift distance, by looking at the deciphered output. What if we could do this automatically?\nA simple approach that would cover many cases would be to use a word list, and check if the deciphered output contains any words from the word list. If it does, we can assume that we have found the correct shift distance. We can even try each of the shift distances that we calculated in the previous section, and see if any of them produce readable output, and then score the output based on how many readable words we find.\nI’ll use <a href=\"http://ogden.basic-english.org/words.html\">“Ogden’s basic english word list”</a> for this code. This is a list of 850 words that are commonly used in the English language. We can use this list to check if the deciphered output contains any words from the list.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">crackCaesarCipher</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cipherText</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Try each shift distance and print the result</span>\n  <span class=\"token keyword\">let</span> bestScore <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">let</span> bestShift <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> alphabet<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> shift <span class=\"token operator\">=</span> i\n    <span class=\"token keyword\">const</span> decipheredText <span class=\"token operator\">=</span> <span class=\"token function\">caesarDecipher</span><span class=\"token punctuation\">(</span>shift<span class=\"token punctuation\">,</span> cipherText<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> readableWords <span class=\"token operator\">=</span> words<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">word</span> <span class=\"token operator\">=></span> decipheredText<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> score <span class=\"token operator\">=</span> readableWords<span class=\"token punctuation\">.</span>length <span class=\"token operator\">/</span> words<span class=\"token punctuation\">.</span>length\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>score <span class=\"token operator\">></span> bestScore<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      bestScore <span class=\"token operator\">=</span> score\n      bestShift <span class=\"token operator\">=</span> shift\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> bestShift\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This brute force approach will reliably find the correct shift distance for most cases, including cases where the plaintext <a href=\"https://en.wikipedia.org/wiki/Gadsby_(novel)\">doesn’t contain the letter <code class=\"language-text\">e</code></a>. However, it is not perfect. For example, if the ciphertext contains a word that is not in the word list, it will not be detected. Using “1337speak” and replacing letters for numbers in your plaintext could defeat this decryption method. Additionally, intentionally leaving spelling mistakes in your plaintext could also defeat this method. It’s also worth noting that this method is not very efficient, as it will try every possible shift distance, even if the ciphertext doesn’t contain any words from the word list.</p>\n<p>What’s next? I’d love to generalize this word list solution so that it can handle partial word matches and spelling mistakes. I’d also like to try and find a way to detect the shift distance without using a word list (possibly by going back to a frequency analysis of the plaintext) and expand it to cover other single substitution ciphers. If you have any ideas, please let me know!</p>","frontmatter":{"title":"Exploring Cryptography - Frequency Analysis","date":"March 19, 2023"}}},"pageContext":{"slug":"/exploring-cryptography-frequency-analysis-pt-2/","previous":{"fields":{"slug":"/exploring-cryptography-frequency-analysis/"},"frontmatter":{"title":"Exploring Cryptography - Frequency Analysis pt.2"}},"next":null}},"staticQueryHashes":[],"slicesMap":{}}